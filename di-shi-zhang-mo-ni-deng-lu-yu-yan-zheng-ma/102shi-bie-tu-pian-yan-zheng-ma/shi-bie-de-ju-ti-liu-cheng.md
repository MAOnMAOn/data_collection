## 识别的具体流程

### 1. 灰度化
灰度化应用很广，而且也比较简单。灰度图就是将白与黑中间的颜色等分为若干等级，绝大多数位256阶。在RGB模型种，黑色（R=G=B=0）与白色（R=G=B=255），那么256阶的灰度划分就是R=G=B=i，其中i取0到255.
从前面可以知道，OpenCV 读取图片之后图像的颜色数据矩阵默认是3通道的，也就是RGB模型，所以每个pixel都有3个分量，分别代表r，g和b的值。因此将三个分量值都改为同一个灰度值，图片就实现灰度化。

灰度化的方法一般有以下几种：

1. 分量法 
>在rgb三个分量种按照需求选取一个分量作为灰度值。

2. 最大值 
>选取rgb的最大值作为该pixel的灰度值。

3. 平均值 
>g[i,j] = (r[i,j] + g[i,j] + b[i,j]) / 3,取rgb的平均值作为灰度值。

4. 加权变换 
>由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像。
g[i,j] = 0.3*r[i,j] + 0.59*g[i,j] + 0.11*b[i,j]
而 OpenCV 提供了灰度化的 API，这里就直接调用了，采用的是加权变换的方法。

这里我们简单截取一张验证码图片进行转换，图片如下：

![](/assets/88888.png)

代码示例如下：

```
import cv2
import matplotlib.pyplot as plt

# 灰度图转换有多重不同的算法实现，这里使用的算法对应的函数为imread，0代表读入灰度图
img = cv2.imread('test_pic.png', 0)
plt.imshow(img, 'gray')
plt.show()
```
运行结果：

![](/assets/截图_2017-10-28_21-02-20.png)

### 2. 二值化
故名思议，就是整个图像所有像素只有两个值可以选择，一个是黑（灰度为0），一个是白（灰度为255）。二值化的好处就是将图片上的有用信息和无用信息区分开来，比如二值化之后的验证码图片，验证码像素为黑色，背景和干扰点为白色，这样后面对验证码像素处理的时候就会很方便。

常见的二值化方法为固定阀值和自适应阀值，固定阀值就是制定一个固定的数值作为分界点，大于这个阀值的像素就设为255，小于该阀值就设为0，这种方法简单粗暴，但是效果不一定好。另外就是自适应阀值，每次根据图片的灰度情况找合适的阀值。自适应阀值的方法有很多，这里采用了一种类似K均值的方法，就是先选择一个值作为阀值，统计大于这个阀值的所有像素的灰度平均值和小于这个阀值的所有像素的灰度平均值，再求这两个值的平均值作为新的阀值。重复上面的计算，直到每次更新阀值后，大于该阀值和小于该阀值的像素数目不变为止。

这里，我们调用原始验证码，进行简单的代码演示：

```
import cv2
from PIL import Image
import matplotlib.pyplot as plt

img = cv2.imread('test_pic.png', 0)
ret, th = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
cv2.imwrite('temp.png', th)
image1 = Image.open('temp2.png')
image1.show()
```

运行结果：

![](/assets/222222.png)
